// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
        email,
        phone,
        password_hash,
        first_name,
        last_name,
        status,
        kyc_status,
        created_at,
        updated_at
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning id, email, phone, password_hash, first_name, last_name, status, kyc_status, created_at, updated_at
`

type CreateUserParams struct {
	Email        string             `json:"email"`
	Phone        string             `json:"phone"`
	PasswordHash string             `json:"password_hash"`
	FirstName    string             `json:"first_name"`
	LastName     string             `json:"last_name"`
	Status       UserStatus         `json:"status"`
	KycStatus    KycStatus          `json:"kyc_status"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.Phone,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
		arg.Status,
		arg.KycStatus,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Status,
		&i.KycStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateUser = `-- name: DeactivateUser :exec
UPDATE users
set user_status = 'deleted'
WHERE ID = $1
`

func (q *Queries) DeactivateUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deactivateUser, id)
	return err
}

const existsByEmail = `-- name: ExistsByEmail :one
SELECT EXISTS(
        SELECT 1
        FROM users
        WHERE email = $1
    )
`

func (q *Queries) ExistsByEmail(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, existsByEmail, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getByEmail = `-- name: GetByEmail :one
SELECT id,
    email,
    phone,
    password_hash,
    first_name,
    last_name,
    status,
    kyc_status,
    created_at,
    updated_at
FROM users
WHERE email = $1
`

func (q *Queries) GetByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Status,
		&i.KycStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getByID = `-- name: GetByID :one
SELECT id,
    email,
    phone,
    password_hash,
    first_name,
    last_name,
    status,
    kyc_status,
    created_at,
    updated_at
FROM users
WHERE id = $1
`

func (q *Queries) GetByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Status,
		&i.KycStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getByPhone = `-- name: GetByPhone :one
SELECT id,
    email,
    phone,
    password_hash,
    first_name,
    last_name,
    status,
    kyc_status,
    created_at,
    updated_at
FROM users
WHERE phone = $1
`

func (q *Queries) GetByPhone(ctx context.Context, phone string) (User, error) {
	row := q.db.QueryRow(ctx, getByPhone, phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Status,
		&i.KycStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE users
SET password_hash = $2
WHERE ID = $1
`

type UpdatePasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash string      `json:"password_hash"`
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET email = $2,
    phone = $3,
    password_hash = $4,
    first_name = $5,
    last_name = $6,
    status = $7,
    kyc_status = $8,
    updated_at = $9
WHERE id = $1
returning id, email, phone, password_hash, first_name, last_name, status, kyc_status, created_at, updated_at
`

type UpdateUserParams struct {
	ID           pgtype.UUID        `json:"id"`
	Email        string             `json:"email"`
	Phone        string             `json:"phone"`
	PasswordHash string             `json:"password_hash"`
	FirstName    string             `json:"first_name"`
	LastName     string             `json:"last_name"`
	Status       UserStatus         `json:"status"`
	KycStatus    KycStatus          `json:"kyc_status"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Email,
		arg.Phone,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
		arg.Status,
		arg.KycStatus,
		arg.UpdatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Status,
		&i.KycStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
